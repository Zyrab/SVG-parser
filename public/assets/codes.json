{
  "toPath2D": "export const toPath2D = (shapeData) => {\n\tconst shapes = []; // Array to store cached shapes\n\tlet dims = { w: 0, h: 0 }; // Default dimensions\n\tshapeData.forEach((p) => {\n\t\tlet path = null; // Initialize path variable for each shape\n\n\t\t// Set the center based on SVG width and height\n\t\tif (p.svg) {\n\t\t\tdims.w = p.svg.width;\n\t\t\tdims.h = p.svg.height;\n\t\t\treturn; // Skip this iteration as it's the svg container\n\t\t}\n\n\t\t// Check for different shape types and create corresponding Path2D objects\n\t\tif (p.path) {\n\t\t\tpath = new Path2D(p.path); // Path element\n\t\t}\n\t\t// Store the shape only if a valid path exists\n\t\tif (path) {\n\t\t\tlet shape = { path };\n\n\t\t\t// Assign fill color or gradient\n\t\t\tif (typeof p.fill === \"string\") {\n\t\t\t\tshape.fs = p.opacity ? hexToRgba(p.fill, p.opacity) : p.fill;\n\t\t\t}\n\t\t\tif (typeof p.stroke === \"string\") {\n\t\t\t\tshape.st = p.opacity ? hexToRgba(p.stroke, p.opacity) : p.stroke;\n\t\t\t\tif (p.strokeWidth) shape.stw = p.strokeWidth; // Stroke width\n\t\t\t}\n\n\t\t\t// Handle gradient fills\n\t\t\tif (typeof p.fill === \"object\") {\n\t\t\t\tif (p.fill.type === \"linear\") shape.fsln = p.fill; // Linear gradient fill\n\t\t\t\tif (p.fill.type === \"radial\") shape.fsrd = p.fill; // Radial gradient fill\n\t\t\t}\n\n\t\t\t// Handle gradient strokes\n\t\t\tif (typeof p.stroke === \"object\") {\n\t\t\t\tif (p.stroke.type === \"linear\") shape.stln = p.stroke; // Linear gradient stroke\n\t\t\t\tif (p.stroke.type === \"radial\") shape.strd = p.stroke; // Radial gradient stroke\n\t\t\t\tif (p.strokeWidth) shape.stw = p.strokeWidth; // Stroke width for gradients\n\t\t\t}\n\n\t\t\tshapes.push(shape); // Add the shape to the array\n\t\t}\n\t});\n\n\treturn { shapes, dims }; // Return the cached shapes and the center of the SVG\n};\n\nfunction hexToRgba(hex, opacity = 1) {\n\tif (!hex.startsWith(\"#\")) return hex; // already rgba, hsl, or named color\n\n\tlet r, g, b;\n\n\tif (hex.length === 4) {\n\t\tr = parseInt(hex[1] + hex[1], 16);\n\t\tg = parseInt(hex[2] + hex[2], 16);\n\t\tb = parseInt(hex[3] + hex[3], 16);\n\t} else if (hex.length === 7) {\n\t\tr = parseInt(hex.slice(1, 3), 16);\n\t\tg = parseInt(hex.slice(3, 5), 16);\n\t\tb = parseInt(hex.slice(5, 7), 16);\n\t} else {\n\t\t// Invalid format, return as-is\n\t\treturn hex;\n\t}\n\n\treturn `rgba(${r}, ${g}, ${b}, ${opacity})`;\n}",
  "drawShape": "export const drawShape = (ctx, shapes) => {\n\t// Loop through each shape and draw it with its respective styles\n\tfor (const shape of shapes) {\n\t\t// Determine the fill and stroke styles (solid color or gradient)\n\t\tlet fillStyle =\n\t\t\tshape.fs ||\n\t\t\tapplyGradient(ctx, shape.fsln) ||\n\t\t\tapplyGradient(ctx, shape.fsrd);\n\t\tlet strokeStyle =\n\t\t\tshape.st ||\n\t\t\tapplyGradient(ctx, shape.stln) ||\n\t\t\tapplyGradient(ctx, shape.strd);\n\n\t\t// Apply fill style if defined\n\t\tif (fillStyle) {\n\t\t\tctx.fillStyle = fillStyle;\n\t\t\tctx.fill(shape.path);\n\t\t}\n\n\t\t// Apply stroke style if defined\n\t\tif (strokeStyle) {\n\t\t\tctx.strokeStyle = strokeStyle;\n\t\t\tctx.lineWidth = shape.stw || 1; // Use specified stroke width or default to 1\n\t\t\tctx.stroke(shape.path);\n\t\t}\n\t}\n};\n\nconst applyGradient = (ctx, grad) => {\n\tif (!grad) return null; // Return null if no gradient is provided\n\n\t// Handle linear gradients\n\tif (grad.type === \"linear\") {\n\t\tconst { x1 = 0, y1 = 0, x2 = 100, y2 = 100, stops } = grad;\n\t\tconst gradient = ctx.createLinearGradient(x1, y1, x2, y2);\n\t\tstops.forEach((stop) => gradient.addColorStop(stop.offset, stop.color));\n\t\treturn gradient;\n\t}\n\n\t// Handle radial gradients\n\tif (grad.type === \"radial\") {\n\t\treturn console.warn(\"Radial gradient not supported yet.\");\n\t\tconst { cx, cy, r, r2, stops } = grad;\n\t\tconst gradient = ctx.createRadialGradient(cx, cy, r1, cx, cy, r2);\n\t\tstops.forEach((stop) => gradient.addColorStop(stop.offset, stop.color));\n\t\treturn gradient;\n\t}\n\n\treturn null; // Return null if the gradient type is not recognized\n};",
  "npm": "npm install @zyrab/parsect-renderer",
  "use": "import { toPath2D, drawShape } from \"@zyrab/parsect-renderer\";\n\nconst shapesJson = {converted svg file};\nconst { dims, shapes } = toPath2D(shapesJson); // dims contains width and height of shape\n\nctx.save();\nctx.translate(\n\t(ctx.canvas.width - dims.w * scale) / 2,\n\t(ctx.canvas.height - dims.h * scale) / 2\n);\nctx.scale(scale, scale);\n\ndrawShape(ctx, shapes); // uses canvas drawing methods\n\nctx.restore();"
}
